# 第 3 章：项目初始化与架构设计

## 3.1 项目初始化与代码规范

### 3.1.1 前端 Nuxt 项目初始化

初始化前端项目就像为一栋建筑打下坚实的基础，我们需要遵循最佳实践来确保项目的可维护性和可扩展性。

```bash
# 使用 Nuxt 官方脚手架创建项目
pnpm dlx nuxi@latest init frontend-nuxt
# 进入项目目录
cd frontend-nuxt
# 安装依赖
pnpm install
# 启动开发服务器
pnpm dev
```

创建完成后，我们将得到一个标准的 Nuxt 项目结构，但为了更好地组织代码，我们推荐采用以下目录结构：

```markdown
frontend-nuxt/
├── app.vue                 # 应用根组件
├── nuxt.config.ts          # Nuxt 核心配置文件
├── package.json            # 项目依赖和脚本定义
├── tsconfig.json           # TypeScript 配置
├── components/             # 可复用组件
│   └── common/             # 通用基础组件
├── composables/            # 组合式函数（逻辑复用）
├── layouts/                # 页面布局组件
├── pages/                  # 页面组件（自动路由）
│   ├── index.vue           # 首页
│   └── [...all].vue        # 404 页面
├── public/                 # 静态资源（直接映射到根路径）
└── server/                 # 服务端代码（Nuxt Server Routes）
```

这种结构清晰地区分了不同类型的文件，便于团队协作和后期维护。

### 3.1.2 后端 FastAPI 项目初始化

后端项目初始化同样重要，它决定了整个应用的稳定性和扩展能力。

```bash
# 创建后端项目目录
mkdir backend-fastapi && cd backend-fastapi
# 初始化 Python 项目
pdm init
# 安装核心依赖
pdm add fastapi uvicorn
# 安装开发依赖
pdm add -dG dev pytest httpx
```

推荐的后端项目结构如下：

```markdown
backend-fastapi/
├── app/                    # 应用核心代码
│   ├── __init__.py         # 包标识文件
│   ├── main.py             # 应用入口点
│   ├── api/                # API 路由定义
│   │   ├── __init__.py
│   │   └── v1/             # API v1 版本
│   ├── core/               # 核心配置和安全模块
│   │   ├── __init__.py
│   │   ├── config.py       # 配置管理
│   │   └── security.py     # 安全相关功能
│   ├── models/             # 数据模型定义
│   ├── schemas/            # 数据验证和序列化
│   └── database.py         # 数据库连接管理
├── tests/                  # 测试代码
├── pyproject.toml          # 项目配置和依赖管理
└── README.md               # 项目说明文档
```

这种结构遵循了模块化设计原则，使代码更易于管理和扩展。

### 3.1.3 代码规范配置

良好的代码规范就像统一的「书写语言」，确保团队成员能够轻松理解和维护彼此的代码。

#### 前端代码规范

前端采用 TypeScript + Composition API 的组合，遵循以下规范：

1. **命名规范**
   - 文件名：小驼峰命名法（camelCase）或短横线分隔（kebab-case）
   - 组件名：大驼峰命名法（PascalCase）
   - 变量和函数：小驼峰命名法（camelCase）

2. **组件设计**
   - 优先使用 Composition API 和组合式函数
   - 组件属性（props）需明确定义类型和默认值
   - 组件事件（emits）需明确声明

3. **样式规范**
   - 使用 SCSS 或 CSS Modules 避免样式污染
   - 遵循 BEM 命名约定提高可维护性

#### 后端代码规范

后端采用 Python 编写，遵循 PEP 8 规范和 FastAPI 最佳实践：

1. **命名规范**
   - 模块和包：小写字母，单词间用下划线分隔
   - 类名：大驼峰命名法（PascalCase）
   - 函数和变量：小写字母，单词间用下划线分隔

2. **代码结构**
   - 使用类型注解提高代码可读性和安全性
   - 遵循单一职责原则，保持函数和类的简洁
   - 合理使用依赖注入和中间件

3. **API 设计**
   - 使用 Pydantic 模型进行请求和响应数据验证
   - 明确 HTTP 状态码和错误处理机制

#### 通用规范

无论前端还是后端，都需要遵循以下通用规范：

1. **Git 提交规范**
   - 使用 conventional commits 规范编写提交信息
   - 提交前确保代码通过 lint 和测试

2. **文档规范**
   - 所有公共接口和复杂逻辑必须有清晰注释
   - 重要功能需在 README 中有相应说明

3. **测试规范**
   - 新功能必须包含单元测试
   - 关键业务逻辑需有集成测试覆盖

## 3.2 API 接口设计规范

API 就像应用程序之间的「沟通语言」，设计良好的 API 能够提高开发效率并降低维护成本。

### 3.2.1 RESTful 设计原则

RESTful API 设计就像构建一套「词汇表」，让前后端能够准确无误地交流：

```markdown
# 基础资源操作
GET    /api/v1/articles      # 获取文章列表 - 如同在图书馆查找书籍目录
POST   /api/v1/articles      # 创建新文章 - 如同在图书馆新增一本图书
GET    /api/v1/articles/{id} # 获取指定文章 - 如同查阅某本特定的图书
PUT    /api/v1/articles/{id} # 更新文章 - 如同修改图书内容
DELETE /api/v1/articles/{id} # 删除文章 - 如同从图书馆移除某本图书

# 用户资源操作
GET    /api/v1/users/{id}    # 获取指定用户信息
POST   /api/v1/users         # 创建新用户
PUT    /api/v1/users/{id}    # 更新用户信息
DELETE /api/v1/users/{id}    # 删除用户

# 嵌套资源操作（文章与评论的关系）
GET    /api/v1/articles/{id}/comments  # 获取文章评论 - 如同查看图书的读者留言
POST   /api/v1/articles/{id}/comments # 创建文章评论 - 如同添加新的读者留言
PUT    /api/v1/articles/{id}/comments/{comment_id} # 更新评论 - 如同修改已有的读者留言
DELETE /api/v1/articles/{id}/comments/{comment_id} # 删除评论 - 如同删除某条读者留言
```

### 3.2.2 响应格式标准化

标准化的响应格式就像统一的「信息模板」，让前端能够以一致的方式处理各种响应。我们定义了以下两种响应格式：

```typescript
// 成功响应 - 清晰地告知客户端操作成功及返回的数据
{ 
  "status": "success",     // 状态标识
  "data": {                // 响应数据主体
    "id": 1,
    "title": "文章标题",
    "content": "文章内容"
  },
  "message": "操作成功"    // 操作结果描述
}

// 错误响应 - 详细说明错误原因，帮助前端排查问题
{ 
  "status": "error",       // 状态标识
  "error": {               // 错误信息详情
    "code": "VALIDATION_ERROR",      // 错误代码
    "message": "输入数据验证失败",   // 错误概要
    "details": [                      // 详细错误信息
      { 
        "field": "title",            // 出错的字段
        "message": "标题不能为空"     // 具体错误描述
      }
    ]
  }
}
```

### 3.2.3 API 版本管理策略

API 版本管理就像软件的「时间线」，让我们能够在不影响现有功能的前提下进行迭代更新：

```
/api/v1/...    # 当前稳定版本，所有生产环境使用
/api/v2/...    # 开发中的下一版本，包含新功能和改进
```

通过版本号区分不同阶段的 API，可以确保向后兼容性，同时为新功能开发提供灵活的空间。

## 3.3 数据库选型与 SQLAlchemy 实践

数据库就像是网站的「记忆仓库」，负责存储和管理所有数据。我们选择 SQLAlchemy 作为 ORM （对象关系映射） 工具，并根据不同环境选择合适的数据库：

### 3.3.1 开发环境 - SQLite

在开发阶段，我们选择 SQLite 作为数据库，它就像一个轻便的「笔记本」，无需额外配置即可使用：

```python
# 优势
- 零配置，文件式数据库，随项目一起移动
- 适合开发和测试环境，启动迅速
- 快速原型开发的理想选择
- 占用资源少，对于小型项目足够高效

# 配置示例
DATABASE_URL = "sqlite:///./app.db"  # 简单的文件路径配置
```

### 3.3.2 生产环境 - PostgreSQL

在生产环境中，我们选择 PostgreSQL 作为数据库，它就像一个功能强大的「专业仓库」，能够应对高并发和复杂查询：

```python
# 优势
- 高性能，支持高并发访问
- 丰富的功能特性，如 JSON 支持、全文搜索等
- 完善的数据完整性保障机制
- 优秀的扩展性和稳定性
- 社区活跃，文档完善

# 配置示例
DATABASE_URL = "postgresql://user:pass@localhost:5432/dbname"  # 连接生产数据库
```

### 3.3.3 SQLAlchemy 数据模型设计

SQLAlchemy 让我们能够用面向对象的方式定义数据模型，就像设计「数据蓝图」一样：

```python
# SQLAlchemy 模型定义示例
from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime

class User(Base):
    __tablename__ = "users"  # 数据库表名
    
    id = Column(Integer, primary_key=True, index=True)  # 主键
    email = Column(String, unique=True, index=True)     # 唯一索引
    hashed_password = Column(String)                    # 密码（已加密）
    is_active = Column(Boolean, default=True)           # 用户状态
    created_at = Column(DateTime, default=datetime.utcnow)  # 创建时间
    
    # 关系定义 - 一个用户可以有多篇文章
    articles = relationship("Article", back_populates="author")

class Article(Base):
    __tablename__ = "articles"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)  # 索引字段，提高查询效率
    content = Column(Text)              # 文章内容
    author_id = Column(Integer, ForeignKey("users.id"))  # 外键，关联用户表
    
    # 关系定义 - 一篇文章属于一个作者
    author = relationship("User", back_populates="articles")
    # 多对多关系 - 文章可以有多个标签
    tags = relationship("Tag", secondary="article_tags")
```

SQLAlchemy 的强大之处在于它不仅提供了简单的 CRUD 操作，还支持复杂查询、事务管理、数据迁移等高级功能，是 Python 生态系统中最成熟的 ORM 工具之一。

## 3.4 开发工作流与协作规范

良好的开发工作流就像一套「交通规则」，确保团队成员能够高效协作而不会相互干扰。

### 3.4.1 Git 分支策略概述

Git 分支管理就像项目的「分支树」，不同分支承担不同的开发阶段和任务：

```
main 分支      - 生产环境代码，保持稳定可部署状态
develop 分支   - 开发集成分支，汇集所有功能开发成果
feature/*      - 功能开发分支，每个新功能在独立分支中开发
release/*      - 发布准备分支，为生产环境发布做最后准备
hotfix/*       - 紧急修复分支，处理生产环境中的突发问题
```

### 3.4.2 代码审查流程

代码审查就像「质量检查关卡」，确保所有代码符合质量标准：

```markdown
1. 创建功能分支 - 在独立的分支中开发新功能
2. 开发并提交代码 - 定期提交，保持提交信息清晰
3. 创建 Pull Request - 向团队展示你的工作成果
4. 代码审查 - 至少 1 名团队成员审核代码，提出改进建议
5. 自动化测试 - 确保代码通过所有测试用例
6. 合并到 develop 分支 - 代码通过审查后合并到开发分支
```

### 3.4.3 自动化脚本配置

自动化脚本就像「智能助手」，帮助我们简化重复的开发任务：

```json
// 前端 package.json 脚本
{
  "scripts": {
    "dev": "nuxt dev",  // 启动前端开发服务器
    "dev:all": "concurrently \"pnpm dev\" \"cd backend && python -m uvicorn app.main:app --reload\"",  // 同时启动前后端开发服务
    "build": "nuxt build",  // 构建生产版本
    "lint": "eslint .",  // 代码质量检查
    "type-check": "nuxt type-check"  // TypeScript 类型检查
  }
}
```

```toml
# 后端 pyproject.toml 任务配置
[tool.taskipy.tasks]
# 使用 taskipy 管理后端开发任务
# 启动后端开发服务器，支持热重载
dev = "uvicorn app.main:app --reload --host 0.0.0.0 --port 8000"
# 运行测试用例
test = "pytest"
# 代码风格检查
lint = "flake8 app tests"
# 代码格式化
format = "black app tests"
```

通过这些自动化脚本，我们可以一键启动开发环境、运行测试、检查代码质量等，大大提高了开发效率。

通过以上架构设计和技术选型，我们为个人网站项目建立了一个清晰、可维护、可扩展的全栈开发基础，就像搭建了一座坚固的「数字建筑框架」，为后续的功能开发奠定了坚实的基础。